import {
  Button,
  ButtonGroup,
  FormControl,
  FormHelperText,
  FormLabel,
  Heading,
  IconButton,
  Input,
  InputGroup,
  InputRightAddon,
  Link,
  SimpleGrid,
  Tooltip,
  useToast,
} from "@chakra-ui/react";
import { ChallengeDetails } from "./types";
import { BigNumber, utils } from "ethers";
import { useState } from "react";
import { RepeatIcon } from "@chakra-ui/icons";
import {
  useChallengeAcceptChallenge,
  useChallengeChallengeAcceptedEvent,
  usePrepareChallengeAcceptChallenge,
} from "@/generated";
import { useAccount, useWaitForTransaction } from "wagmi";

export default function ChallengeAcceptGrid({
  challengeDetails,
}: ChallengeAcceptGridProps) {
  //* Local state
  const [challengerPrediction, setChallengerPrediction] = useState<string>("0");
  const [validAcceptChallenge, setValidAcceptChallenge] =
    useState<boolean>(false);

  const toast = useToast();
  const { isConnected, address: currentUserAddress } = useAccount();

  //* Wagmi autogenerated usePrepareContractWrite hook
  const {
    config: challengeAcceptConfig,
    isLoading: isAcceptValidateLoading,
    refetch: refetchChallengeAcceptValidate,
  } = usePrepareChallengeAcceptChallenge({
    // @ts-expect-error
    address: challengeDetails?.challengeAddress ?? "",
    enabled: false,
    args: [utils.parseUnits(challengerPrediction || "0", 8)],
    overrides: {
      value: challengeDetails?.entryFee || 0,
    },
    onError: (error: any) => {
      setValidAcceptChallenge(false);
      toast({
        title: "Cannot accept challenge",
        description: `Contract will throw the following error while accepting the challenge -- ${
          error?.reason || error?.message
        }`,
        status: "error",
        duration: 5000,
        isClosable: true,
      });
    },
    onSuccess: (data) => {
      setValidAcceptChallenge(true);
      toast({
        title: "Accept Challenge parameters validated successfully",
        status: "success",
        duration: 2000,
        isClosable: true,
      });
    },
  });

  //* Contract write hook
  const {
    data: challengeAcceptData,
    isLoading: isChallengeAcceptLoading,
    write: acceptChallenge,
  } = useChallengeAcceptChallenge({
    ...challengeAcceptConfig,
    onError: (error: any) => {
      toast({
        title: "Error sending the accept transaction",
        description: `Error thrown while accepting the challenge -- ${
          error?.reason || error?.message
        }`,
        status: "error",
        duration: 5000,
        isClosable: true,
      });
    },
    onSuccess: (data) => {
      toast({
        title: "Challenge accept request sent",
        status: "success",
        duration: 2000,
        isClosable: true,
      });
    },
  });

  //* Wait for transaction hook
  // Check TX for Challenge Creation
  const { isLoading: isAcceptTxLoading } = useWaitForTransaction({
    confirmations: 1,
    hash: challengeAcceptData?.hash,
    onSuccess: (data) => {
      toast({
        title: "Challenge accept transaction confirmed",
        description: `Transaction hash: ${data?.transactionHash}`,
        status: "success",
        duration: 2000,
        isClosable: true,
      });
    },
    onError: (error: any) => {
      toast({
        title: "Error accepting challenge",
        description: `Transaction failed with error: ${
          error?.reason || error?.message
        }`,
        status: "error",
        duration: 5000,
        isClosable: true,
      });
    },
  });

  //* Wagmi autogenerated useEvent hook
  useChallengeChallengeAcceptedEvent({
    // @ts-expect-error
    address: challengeDetails?.challengeAddress ?? "",
    listener(_challengerAddress: string, _challengerPrediction: BigNumber) {
      if (_challengerAddress === currentUserAddress) {
        challengeDetails?.refetchChallengeDetails?.();
        console.log("Challenge accepted");
        toast({
          title: "Challenge Accepted!",
          description: `Your prediction of ${utils.formatUnits(
            _challengerPrediction,
            8
          )} ETH/USD with address ${currentUserAddress} was accepted.`,
          status: "success",
          duration: 5000,
          isClosable: true,
        });
      }
    },
  });

  return (
    <SimpleGrid
      as={"form"}
      onSubmit={handleChallengeAccept}
      columns={2}
      spacing={4}
    >
      <Heading as="h3" size="md" gridColumn="span 2" fontWeight={100}>
        Accept Challenge
      </Heading>
      <FormControl gridColumn={{ base: "span 2" }} isReadOnly>
        <FormLabel size="md">You will pay</FormLabel>
        <Tooltip
          hasArrow
          label={`Fixed entry fee for accepting the challenge. This is the amount of ETH that will be deducted from your wallet (excluding gas fees).The exact entryFee in WEI is ${
            challengeDetails?.entryFee ?? "?"
          } (1 ETH = 10^18 WEI)`}
          bg="green.600"
          color="white"
        >
          <InputGroup size="md" variant="filled">
            <Input
              variant="filled"
              type="text"
              bg="secondary.100"
              value={
                challengeDetails?.entryFee
                  ? utils.formatEther(challengeDetails?.entryFee)
                  : "Loading..."
              }
              size="md"
            />
            <InputRightAddon bg="secondary.200">ETH</InputRightAddon>
          </InputGroup>
        </Tooltip>
      </FormControl>
      <FormControl isRequired gridColumn={"span 2"}>
        <FormLabel>Your prediction</FormLabel>
        <InputGroup size="md" variant="outline">
          <Input
            variant="outline"
            type="number"
            value={challengerPrediction}
            onChange={(event) => {
              setChallengerPrediction(event.target.value);
            }}
          />
          <InputRightAddon bg="secondary.200">ETH/USD</InputRightAddon>
        </InputGroup>
        <FormHelperText>Enter your prediction of ETH/USD.</FormHelperText>
      </FormControl>
      <ButtonGroup gap={4}>
        <Tooltip
          hasArrow
          label="Validate accept challenge parameters before creating the challenge"
          bg="green.600"
          color="white"
        >
          <IconButton
            aria-label="Validate challenge parameters"
            colorScheme="green"
            icon={<RepeatIcon />}
            isLoading={isAcceptValidateLoading}
            onClick={validateAcceptChallenge}
          />
        </Tooltip>
        <Tooltip
          hasArrow
          label={`Accept challenge with ${
            utils.formatEther(challengeDetails?.entryFee || 0) ?? "?"
          } ETH entry fee and ${
            challengerPrediction ?? "?"
          } ETH/USD prediction`}
          bg="green.600"
          color="white"
        >
          <Button
            type="submit"
            colorScheme={isAcceptTxLoading ? "blue" : "green"}
            isDisabled={
              !validAcceptChallenge ||
              isChallengeAcceptLoading ||
              isAcceptTxLoading
            }
            isLoading={isChallengeAcceptLoading || isAcceptTxLoading}
            alignSelf="center"
          >
            Accept Challenge
          </Button>
        </Tooltip>
      </ButtonGroup>
    </SimpleGrid>
  );

  async function validateAcceptChallenge() {
    await refetchChallengeAcceptValidate();
  }

  function handleChallengeAccept(event: React.FormEvent) {
    event.preventDefault();
    acceptChallenge?.();
  }
}

export type ChallengeAcceptGridProps = {
  challengeDetails: ChallengeDetails;
};
